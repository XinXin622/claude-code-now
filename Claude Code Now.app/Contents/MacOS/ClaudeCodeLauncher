#!/bin/bash

# 🖥 Claude Code Now - 极简版
# 功能：检测当前目录，询问用户选择终端，启动 claude

# 尝试加载用户 shell 配置以获取 PATH
if [ -f "$HOME/.zshrc" ]; then
    # shellcheck disable=SC1090
    source "$HOME/.zshrc" 2>/dev/null || true
elif [ -f "$HOME/.bashrc" ]; then
    # shellcheck disable=SC1090
    source "$HOME/.bashrc" 2>/dev/null || true
elif [ -f "$HOME/.bash_profile" ]; then
    # shellcheck disable=SC1090
    source "$HOME/.bash_profile" 2>/dev/null || true
elif [ -f "$HOME/.zprofile" ]; then
    # shellcheck disable=SC1090
    source "$HOME/.zprofile" 2>/dev/null || true
fi

# 补充常见 PATH，避免 GUI 启动找不到 claude
export PATH="$HOME/.npm-global/bin:$HOME/.npm/bin:$HOME/Library/pnpm:$HOME/.local/bin:$HOME/.cargo/bin:/usr/local/bin:/opt/homebrew/bin:/usr/local/share/npm/bin:$PATH"

# 查找 claude 可执行文件
CLAUDE_PATH="$(command -v claude 2>/dev/null || true)"

# 未找到 claude 给出提示
if [ -z "$CLAUDE_PATH" ]; then
    osascript -e "display alert \"Claude CLI Not Found\" message \"未找到 claude，可尝试:\n\n1) 终端运行: command -v claude\n2) 使用 npm 安装: npm install -g @anthropic-ai/claude-code\n3) 检查 PATH 是否包含 Homebrew 或 npm 目录\""
    exit 1
fi

# 获取目标目录
TARGET_DIR="$1"

# 如果没有参数，从 Finder 获取当前目录
if [ -z "$TARGET_DIR" ]; then
    TARGET_DIR=$(osascript -e 'tell application "Finder" to get POSIX path of (target of front window as alias)' 2>/dev/null)
fi

# 如果还是没有，用主目录
if [ -z "$TARGET_DIR" ]; then
    TARGET_DIR="$HOME"
fi

# 检测可用终端（只保留 Ghostty、Terminal）
TERMINALS=()
[ -d "/Applications/Ghostty.app" ] && TERMINALS+=("Ghostty")
TERMINALS+=("Terminal")  # 系统终端总是可用

# 偏好设置文件（删除此文件可重置终端选择：rm ~/.config/claude-code-now/terminal）
PREF_DIR="$HOME/.config/claude-code-now"
PREF_FILE="$PREF_DIR/terminal"

# 读取已保存的偏好
SAVED_TERMINAL=""
if [ -f "$PREF_FILE" ]; then
    SAVED_TERMINAL=$(cat "$PREF_FILE")
fi

# 验证保存的终端是否仍然可用
SAVED_VALID=false
for t in "${TERMINALS[@]}"; do
    if [ "$t" = "$SAVED_TERMINAL" ]; then
        SAVED_VALID=true
        break
    fi
done

# 决定是否需要显示选择对话框
NEED_DIALOG=false
if [ ${#TERMINALS[@]} -eq 1 ]; then
    # 只有一个选项，直接使用
    CHOICE="${TERMINALS[0]}"
elif [ "$SAVED_VALID" = "true" ]; then
    # 有有效的保存偏好，直接使用
    CHOICE="$SAVED_TERMINAL"
else
    # 首次使用或偏好无效，显示对话框
    NEED_DIALOG=true
fi

if [ "$NEED_DIALOG" = "true" ]; then
    # 构建 AppleScript 列表
    AS_LIST="{"
    FIRST=true
    for t in "${TERMINALS[@]}"; do
        if [ "$FIRST" = true ]; then
            AS_LIST="$AS_LIST\"$t\""
            FIRST=false
        else
            AS_LIST="$AS_LIST, \"$t\""
        fi
    done
    AS_LIST="$AS_LIST}"

    # 弹出选择框（在 Finder 上下文中显示确保获得焦点）
    CHOICE=$(osascript <<EOF
tell application "Finder"
    activate
    choose from list $AS_LIST with prompt "选择终端启动 Claude Code:" with title "Claude Code Now" default items {"${TERMINALS[0]}"}
end tell
EOF
)

    # 用户取消
    if [ "$CHOICE" = "false" ] || [ -z "$CHOICE" ]; then
        exit 0
    fi
    
    # 保存用户选择
    mkdir -p "$PREF_DIR"
    echo "$CHOICE" > "$PREF_FILE"
fi

# 根据选择启动
case "$CHOICE" in

    "Ghostty")
        # Ghostty: 创建临时脚本执行
        TEMP_SCRIPT=$(mktemp /tmp/claude_launcher.XXXXXX)
        cat > "$TEMP_SCRIPT" << SCRIPT
#!/bin/zsh
# 加载用户 shell 配置以获取 PATH
[[ -f ~/.zshrc ]] && source ~/.zshrc 2>/dev/null

# 切换到目标目录
cd '$TARGET_DIR'

# 执行 claude (yolo 模式)
claude --dangerously-skip-permissions

# 保持终端打开
exec zsh
SCRIPT
        chmod +x "$TEMP_SCRIPT"
        
        # 获取目录名作为标题
        DIR_NAME=$(basename "$TARGET_DIR")
        
        # 使用 Ghostty 执行脚本，设置标题和工作目录
        /Applications/Ghostty.app/Contents/MacOS/ghostty --title="$DIR_NAME" --working-directory="$TARGET_DIR" -e "$TEMP_SCRIPT" &
        
        # 延迟删除临时脚本
        (sleep 5 && rm -f "$TEMP_SCRIPT") &
        ;;
    "Terminal"|*)
        # 系统终端 - 直接在窗口执行命令
        DIR_NAME=$(basename "$TARGET_DIR")
        osascript <<EOF
tell application "Terminal"
    activate
    if (count of windows) = 0 then
        do script "cd '$TARGET_DIR' && claude --dangerously-skip-permissions"
    else
        do script "cd '$TARGET_DIR' && claude --dangerously-skip-permissions" in front window
    end if
    set custom title of front window to "$DIR_NAME"
    set frontmost to true
end tell
EOF
        ;;
esac